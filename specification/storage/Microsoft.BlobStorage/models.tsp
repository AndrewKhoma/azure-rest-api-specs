import "@typespec/rest";
import "@typespec/http";
import "@azure-tools/typespec-azure-core";
import "@azure-tools/typespec-client-generator-core";

using Azure.Core;
using TypeSpec.Rest;
using TypeSpec.Http;
using TypeSpec.Versioning;
using Azure.ClientGenerator.Core;

@useDependency(Azure.Core.Versions.v1_0_Preview_1)
namespace Microsoft.BlobStorage;

@error
@doc("The error response.")
model StorageError {
  @doc("The error message.")
  Message: string;
}

@doc("The account kind.")
enum AccountKind {
  @doc("The storage account is a general-purpose account.")
  Storage,
  @doc("The storage account is a blob storage account.")
  BlobStorage,
  @doc("The storage account is a storage V2 account.")
  StorageV2,
  @doc("The storage account is a file storage account.")
  FileStorage,
  @doc("The storage account is a block blob storage account.")
  BlockBlobStorage
}

@doc("The SKU types")
enum SkuName {
  @doc("The standard LRS SKU.")
  Standard_LRS,
  @doc("The standard GRS SKU.")
  Standard_GRS,
  @doc("The standard RAGRS SKU.")
  Standard_RAGRS,
  @doc("The standard ZRS SKU.")
  Standard_ZRS,
  @doc("The premium LRS SKU.")
  Premium_LRS
}

model ListContainersSegmentResponse {
  @doc("The service endpoint.")
  ServiceEndpoint: string; // TODO: XML Attribute

  @doc("The prefix of the containers.")
  Prefix?: string;

  @doc("The marker of the containers.")
  Marker?: string;

  @doc("The max results of the containers.")
  MaxResults?: int32;

  @doc("The container segment.")
  Segment: ContainerItem[]; // TODO: XML Serialization

  @doc("The next marker of the containers.")
  NextMarker?: string;
}

@doc("An Azure Storage container.")
model ContainerItem {
  @doc("The name of the container.")
  Name: string;

  @doc("The properties of the container.")
  Properties: ContainerProperties;

  @doc("The metadata of the container.")
  Metadata?: ContainerMetadata;
}

@doc("The properties of a container.")
model ContainerProperties {
  @doc("The date-time the container was created in RFC1123 format.")
  @encode("date-time-rfc1123")
  `Creation-Time`?: utcDateTime;

  @doc("The date-time the container was last modified in RFC1123 format.")
  @encode("date-time-rfc1123")
  `Last-Modified`: utcDateTime;

  @doc("The ETag of the container.")
  ETag: string;

  @doc("The lease status of the container.")
  LeaseStatus?: LeaseStatus;

  @doc("The lease state of the container.")
  LeaseState?: LeaseState;

  @doc("The lease duration of the container.")
  LeaseDuration?: LeaseDuration;

  @doc("The public access type of the container.")
  PublicAccess?: PublicAccessType;
}

@doc("The metadata of a container.")
model ContainerMetadata is Record<string> {
  // @xml.attribute(true)
  Encrypted: string;
}

@doc("Stats for the storage service.")
model StorageServiceStats {
  @doc("The geo replication stats.")
  GeoReplication: GeoReplication;
}

@doc("The geo replication status.")
model GeoReplication {
  Status: GeoReplicationStatus;
  LastSyncTime: string;
}

@doc("The geo replication status.")
enum GeoReplicationStatus {
  @doc("The geo replication is live.")
  live,
  @doc("The geo replication is bootstrap.")
  bootstrap,
  @doc("The geo replication is unavailable.")
  unavailable
}

@doc("Key information")
model KeyInfo {
  @doc("The date-time the key is active.")
  Start: string;
  
  @doc("The date-time the key expires.")
  Expiry: string;
}

@doc("A user delegation key.")
model UserDelegationKey {
  @doc("The Azure Active Directory object ID in GUID format.")
  SignedOid: uuid;

  @doc("The Azure Active Directory tenant ID in GUID format.")
  SignedTid: uuid;

  @doc("The date-time the key is active.")
  SignedStart: string;

  @doc("The date-time the key expires.")
  SignedExpiry: string;

  @doc("Abbreviation of the Azure Storage service that accepts the key.")
  SignedService: string;

  @doc("The service version that created the key.")
  SignedVersion: string;

  @doc("The key as a base64 string.")
  Value: string;
}

@doc("The public access types.")
enum PublicAccessType {
  @doc("Blob access.")
  blob,
  @doc("Container access.")
  container,
}

@doc("The copy status.")
enum CopyStatus {
  @doc("The copy operation is pending.")
  pending,
  @doc("The copy operation succeeded.")
  success,
  @doc("The copy operation failed.")
  failed,
  @doc("The copy operation is aborted.")
  aborted,
}

@doc("The lease duration.")
enum LeaseDuration {
  @doc("The lease is of infinite duration.")
  infinite,
  @doc("The lease is of fixed duration.")
  fixed,
}

@doc("The lease state.")
enum LeaseState {
  @doc("The lease is available.")
  available,
  @doc("The lease is currently leased.")
  leased,
  @doc("The lease is expired.")
  expired,
  @doc("The lease is breaking.")
  breaking,
  @doc("The lease is broken.")
  broken,
}

@doc("The lease status.")
enum LeaseStatus {
  @doc("The lease is unlocked.")
  unlocked,
  @doc("The lease is locked.")
  locked,
}

@doc("Represents an access policy.")
model AccessPolicy {
  @doc("The date-time the policy is active.")
  Start: utcDateTime;
  
  @doc("The date-time the policy expires.")
  Expiry: utcDateTime;
  
  @doc("The permissions for acl the policy.")
  Permission: string;
}

@doc("The access tiers.")
enum AccessTier {
  @doc("The hot P4 tier.")
  P4,
  @doc("The hot P6 tier.")
  P6,
  @doc("The hot P10 tier.")
  P10,
  @doc("The hot P15 tier.")
  P15,
  @doc("The hot P20 tier.")
  P20,
  @doc("The hot P30 tier.")
  P30,
  @doc("The hot P40 tier.")
  P40,
  @doc("The hot P50 tier.")
  P50,
  @doc("The hot P60 tier.")
  P60,
  @doc("The hot P70 tier.")
  P70,
  @doc("The hot P80 tier.")
  P80,
  @doc("The hot access tier.")
  Hot,
  @doc("The cool access tier.")
  Cool,
  @doc("The archive access tier.")
  Archive,
}

@doc("The archive status.")
enum ArchiveStatus {
  @doc("The archive status is rehydrating pending to hot.")
  `rehydrate-pending-to-hot`,
  @doc("The archive status is rehydrating pending to cool.")
  `rehydrate-pending-to-cool`,
  @doc("The archive status is rehydrating pending to archive.")
  `rehydrate-pending-to-archive`,
  @doc("The archive status is rehydrating pending to expired.")
  `rehydrate-pending-to-expired`,
}

@doc("An Azure Storage Blob")
model BlobItem {
  // TODO: Add XML attribute of Encoded
  @doc("The name of the blob.")
  Name: string;

  @doc("Whether the blob is deleted.")
  Deleted: boolean;

  @doc("The snapshot of the blob.")
  Snapshot: string;

  @doc("The version id of the blob.")
  VersionId?: string;

  @doc("Whether the blob is the current version.")
  IsCurrentVersion?: boolean;

  @doc("The properties of the blob.")
  Properties: BlobProperties;

  @doc("The metadata of the blob.")
  Metadata?: BlobMetadata;

  @doc("The tags of the blob.")
  Tags?: BlobTag[];

  @doc("The object replication metadata of the blob.")
  ObjectReplicationMetadata?: ObjectReplicationMetadata;

  @doc("Whether the blog has versions only.")
  HasVersionsOnly?: boolean;
}

@doc("The properties of a blob.")
model BlobProperties {
  @doc("The date-time the blob was created in RFC1123 format.")
  @encode("date-time-rfc1123")
  `Creation-Time`?: utcDateTime;

  @doc("The date-time the blob was last modified in RFC1123 format.")
  @encode("date-time-rfc1123")
  `Last-Modified`: utcDateTime;

  @doc("The blog ETag.")
  ETag: string;

  @doc("The content length of the blob.")
  `Content-Length`?: int64;

  @doc("The content type of the blob.")
  `Content-Type`?: string;

  @doc("The content encoding of the blob.")
  `Content-Encoding`?: string;

  @doc("The content language of the blob.")
  `Content-Language`?: string;

  @doc("The content MD5 of the blob.")
  `Content-MD5`?: string;

  @doc("The content disposition of the blob.")
  `Content-Disposition`?: string;

  @doc("The cache control of the blob.")
  `Cache-Control`?: string;

  @doc("The sequence number of the blob.")
  `x-ms-blob-sequence-number`?: int64;

  @doc("The blob type.")
  BlobType?: BlobType;

  @doc("The lease status of the blob.")
  LeaseStatus?: LeaseStatus;

  @doc("The lease state of the blob.")
  LeaseState?: LeaseState;

  @doc("The lease duration of the blob.")
  LeaseDuration?: LeaseDuration;

  @doc("The copy ID of the blob.")
  CopyId?: string;

  @doc("The copy status of the blob.")
  CopyStatus?: CopyStatus;

  @doc("The copy source of the blob.")
  CopySource?: string;

  @doc("The copy progress of the blob.")
  CopyProgress?: string;

  @doc("The copy completion time of the blob.")
  @encode("date-time-rfc1123")
  CopyCompletionTime?: utcDateTime;

  @doc("The copy status description of the blob.")
  CopyStatusDescription?: string;

  @doc("Whether the blog is encrypted on the server.")
  ServerEncrypted?: boolean;

  @doc("Whether the blog is incremental copy.")
  IncrementalCopy?: boolean;

  @doc("The name of the desination snapshot.")
  DestinationSnapshot?: string;

  @doc("The time the blob was deleted.")
  DeletedTime?: utcDateTime;

  @doc("The remaining retention days of the blob.")
  RemainingRetentionDays?: int32;

  @doc("The access tier of the blob.")
  AccessTier?: AccessTier;

  @doc("Whether the access tier is inferred.")
  AccessTierInferred?: boolean;

  @doc("The archive status of the blob.")
  ArchiveStatus?: ArchiveStatus;

  @doc("The encryption scope of the blob.")
  EncryptionScope?: string;

  @doc("The access tier change time of the blob.")
  @encode("date-time-rfc1123")
  AccessTierChangeTime?: utcDateTime;

  @doc("The number of tags for the blob.")
  TagCount?: int32;

  @clientName("ExpiresOn")
  @doc("The expire time of the blob.")
  @encode("date-time-rfc1123")
  `Expiry-Time`?: utcDateTime;

  @clientName("IsSealed")
  @doc("Whether the blob is sealed.")
  Sealed?: boolean;

  @doc("The rehydrate priority of the blob.")
  RehydratePriority?: RehydratePriority;

  @doc("The last access time of the blob.")
  @encode("date-time-rfc1123")
  LastAccessTime?: utcDateTime;

  @clientName("ImmutabilityPolicyExpiresOn")
  @doc("The immutability policy until time of the blob.")
  @encode("date-time-rfc1123")
  ImmutabilityPolicyUntilDate?: utcDateTime;

  @doc("The immutability policy mode of the blob.")
  ImmutabilityPolicyMode?: BlobImmutabilityPolicyMode;

  @doc("Whether the blob is under legal hold.")
  LegalHold?: boolean;
}

@doc("The immutability policy mode.")
enum BlobImmutabilityPolicyMode {
  @doc("The immutability policy is mutable.")
  Mutable,
  @doc("The immutability policy is locked.")
  Locked,
  @doc("The immutability policy is unlocked.")
  Unlocked
}

@doc("The blob type.")
enum BlobType {
  @doc("The blob is a block blob.")
  BlockBlob,
  @doc("The blob is a page blob.")
  PageBlob,
  @doc("The blob is an append blob.")
  AppendBlob
}

@doc("The rehydrate priority.")
enum RehydratePriority {
  @doc("The rehydrate priority is high.")
  High,
  @doc("The rehydrate priority is standard.")
  Standard
}

@doc("The blob metadata.")
model BlobMetadata is Record<string> {
  // @xml.attribute(true)
  Encrypted: string;
}

@doc("The blob tags.")
model BlobTag {
  @doc("The key of the tag.")
  Key: string;
  @doc("The value of the tag.")
  Value: string;
}

@doc("The object replication metadata.")
model ObjectReplicationMetadata is Record<string>;

/// Service Properties

@doc("The service properties.")
model StorageServiceProperties {
  @doc("The logging properties.")
  Logging?: Logging;
  @doc("The hour metrics properties.")
  HourMetrics?: Metrics;
  @doc("The minute metrics properties.")
  MinuteMetrics?: Metrics;
  @doc("The CORS properties.")
  Cors?: CorsRule[];
  @doc("The default service version.")
  DefaultServiceVersion?: string;
  @doc("The delete retention policy.")
  DeleteRetentionPolicy?: RetentionPolicy;
  @doc("The static website properties.")
  StaticWebsite?: StaticWebsite;
}

@doc("The static website properties.")
model StaticWebsite {
  @doc("The index document.")
  IndexDocument?: string;
  @doc("The error document.")
  ErrorDocument?: string;
}

@doc("The CORS rule.")
model CorsRule {
  @doc("The allowed origins.")
  AllowedOrigins: string;
  @doc("The allowed methods.")
  AllowedMethods: string;
  @doc("The allowed headers.")
  AllowedHeaders: string;
  @doc("The exposed headers.")
  ExposedHeaders: string;
  @doc("The maximum age in seconds.")
  MaxAgeInSeconds: int32;
}

@doc("The metrics properties.")
model Metrics {
  @doc("The version of the metrics properties.")
  Version?: string;
  @doc("Whether it is enabled.")
  Enabled: boolean;
  @doc("Whether to include API in the metrics.")
  IncludeAPIs?: boolean;
  @doc("The retention policy of the metrics.")
  RetentionPolicy?: RetentionPolicy;
  @doc("The service properties of the metrics.")
  ServiceProperties?: MetricsServiceProperties;
}

@doc("The metrics service properties.")
model MetricsServiceProperties {
  @doc("The hour metrics properties.")
  HourMetrics: MetricsProperties;
  @doc("The minute metrics properties.")
  MinuteMetrics: MetricsProperties;
}

@doc("The metrics properties.")
model MetricsProperties {
  @doc("Whether to include API in the metrics.")
  Enabled: boolean;
  @doc("The version of the metrics properties.")
  Version: string;
  @doc("The retention policy of the metrics.")
  RetentionPolicy: RetentionPolicy;
}

@doc("The logging properties.")
model Logging {
  @doc("The version of the logging properties.")
  Version: string;
  @doc("Whether delete operation is logged.")
  Delete: boolean;
  @doc("Whether read operation is logged.")
  Read: boolean;
  @doc("Whether write operation is logged.")
  Write: boolean;
  @doc("The retention policy of the logs.")
  RetentionPolicy: RetentionPolicy;
}

@doc("The retention policy.")
model RetentionPolicy {
  @doc("Whether to enable the retention policy.")
  Enabled: boolean;
  @doc("The number of days to retain the logs.")
  Days: int32;
  @doc("Whether to allow permanent delete.")
  AllowPermanentDelete: boolean;
}

// List Blobs

@doc("An enumeration of blobs.")
model ListBlobsFlatSegmentResponse {
  @doc("The service endpoint.")
  ServiceEndpoint: string; // TODO: XML Attribute

  @doc("The container name.")
  ContainerName: string; // TODO: XML Attribute

  @doc("The prefix of the blobs.")
  Prefix?: string;

  @doc("The marker of the blobs.")
  Marker?: string;

  @doc("The max results of the blobs.")
  MaxResults?: int32;

  @doc("The blob segment.")
  Segment: BlobItem[]; // TODO: XML Serialization

  @doc("The next marker of the blobs.")
  NextMarker?: string;
}
